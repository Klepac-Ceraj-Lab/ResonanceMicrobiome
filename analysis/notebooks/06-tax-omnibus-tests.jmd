---
title: "Notebook 6: Taxonomic Profiles Ombnibus Tests"
author: "Kevin Bonham, PhD"
options:
    line_width : 120
    wrap : false
---

Here, we use permutational analysis of variance
(or [PERMANOVA](https://en.wikipedia.org/wiki/Permutational_analysis_of_variance))
to identify how much of the variation in the microbiome
is explainable by different bits of metadata.
`BiobakeryUtils.jl` uses `RCall` to call the R package [`vegan`](https://cran.r-project.org/web/packages/vegan/index.html)
for their implementation.

```julia; results="hidden"
using Pkg
Pkg.activate("analysis/")
using Revise
```
```julia
ENV["GKSwstype"] = "100"
using ECHOAnalysis
using DataFrames
using SQLite
using StatsPlots
using PrettyTables
using CSV
using Microbiome
using Distances
using MultivariateStats
using Pkg.TOML: parsefile
using Clustering
using MicrobiomePlots
using BiobakeryUtils

function sigp(data, i, j)
    col = names(data)[j]
    if col == Symbol("Pr(>F)") || col == :p_value || col == :qvalue
        dat = data[i,j]
        return !ismissing(dat) && dat < 0.05
    else
        return false
    end
end

sigp_hl = Highlighter(sigp, Crayon(bold = true, background = :dark_gray))

rounder = Dict(0 => (v,i) -> typeof(v) <: AbstractFloat ? round(v,digits=4) : v)
# print ~15 random rows
# randrowfilter(data, i) = rand() < (1 / size(data, 1)) * 15
@ptconfclean # clear previous configuration
@ptconf formatter = rounder nosubheader=true screen_size=(20,120) highlighters=sigp_hl # filters_row=(randrowfilter,)

includet("accessories.jl")

config = parsefile("data/data.toml")
figures = config["output"]["figures"]
tables = config["output"]["tables"]
isdir(figures) || mkpath(figures)
isdir(tables) || mkpath(tables)
```
```julia
db = SQLite.DB(config["sqlite"]["taxa"]["path"])
species = sqlprofile(db, tablename="taxa", kind="species")
```


```julia; results="hidden"
abt = abundancetable(species)
relativeabundance!(abt)
samples = stoolsample.(samplenames(abt))

widemeta = getmgxmetadata(samples=samples)

# would throw error if false
@assert widemeta.sample == sampleid.(samples)
```

```julia; results="hidden"
dm = pairwise(BrayCurtis(), abt, dims=2)
subject_type = [ismom(s) ? "Mother" :
                iskid(s) ? "Child"  :
                error("Not mom or kid: $s") for s in samples]
```
```julia; results="hidden"
perm = permanova(dm, subject_type)
perm[!,:feature] .= "species"
perm[!,:variable] .= "Subject Type"
```
```julia; echo=false
@pt perm
```

In this table, `R2` tells us about the magnitutude of the effect
(`R2 = 0.0202` means 2.02% of variation can be explained by this variable),
and the `Pr(>F)` column is the p value.
The first row is what's being tested (the other two account for what's left).

So this table tells us that, when comparing all the samples,
whether the sample from a mom or a kid (aka `Subject Type`)
can explain ~2% of the variation,
and the result is significant (p < 0.001).

Technically, this p value is a bit anti-conservative,
since we have multiple samples per individual.
But getting an accurate p-value would take a bit of tweaking,
and we don't *really* need to know
what percent of variation is explained by sample type.

One way to demonstrate why mulitple measures are a problem
is to look at how much of the variation is attributable to the subject ID.

```julia; results="hidden"
# need to convert subject IDs to `String` so it's not treated as continuous variable
p = permanova(dm, string.(widemeta.subject))
```
```julia; echo=false
@pt p
```


Here, we can see that over 80% of variability (`R2`) is attributable to who the person is.
Which is to say that people are really different!

Because of this, the numbers from PERMANOVA tend to be small (1-5%),
but even small differences are interesting
(if they're statistically significant).

Now we'll concatenate this new PERMANOVA into the previous dataframe
to keep the results from multiple metadata together.

```julia; results="hidden"
p[!, :feature] .= "species"
p[!, :variable] .= "Subject ID"
perm = vcat(perm, p)
```
```julia; echo=false
@pt perm
```

## Kids metadata PERMANOVAs

Now we'll focus on the kids.

```julia; results="hidden"
uniquekids = uniquetimepoints(samples, samplefilter=iskid)
kids = view(abt, sites=sampleid.(uniquekids))
kids_dm = pairwise(BrayCurtis(), kids, dims=2)

kidsmeta = getmgxmetadata(samples=uniquekids)
@assert kidsmeta.sample == samplenames(kids)

p = permanova(kids_dm, kidsmeta.correctedAgeDays, filter=.!ismissing.(kidsmeta.correctedAgeDays))
p[!, :feature] .= "species"
p[!, :variable] .= "Age"
perm = vcat(perm, p)

kidsmeta.birthType = Vector{Union{Missing,String}}(kidsmeta.birthType)
p = permanova(kids_dm, kidsmeta.birthType, filter=.!ismissing.(kidsmeta.birthType))
p[!, :feature] .= "species"
p[!, :variable] .= "birthType"
perm = vcat(perm, p)

# kidsmeta.breastfed = breastfeeding.(eachrow(kidsmeta))
# p = permanova(kids_dm, kidsmeta.breastfed)
# p[!, :feature] .= "species"
# p[!, :variable] .= "breastfed"
# perm = vcat(perm, p)
#
# kidsmeta.formulafed = formulafeeding.(eachrow(kidsmeta))
# p = permanova(kids_dm, kidsmeta.formulafed)
# p[!, :feature] .= "species"
# p[!, :variable] .= "formulafed"
# perm = vcat(perm, p)

kidsmeta.childGender = Vector{Union{Missing,String}}(kidsmeta.childGender)
p = permanova(kids_dm, kidsmeta.childGender, filter=.!ismissing.(kidsmeta.childGender))
p[!, :feature] .= "species"
p[!, :variable] .= "childGender"
perm = vcat(perm, p)

p = permanova(kids_dm, kidsmeta.mother_HHS, filter=.!ismissing.(kidsmeta.mother_HHS))
p[!, :feature] .= "species"
p[!, :variable] .= "mother_HHS"
perm = vcat(perm, p)

# remove the rows that don't have p values
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
```

```julia; echo=false
@pt perm
```
So, age (`R2 = 0.13`) and maternal socioeconomic status (HHS) (`R2 = 0.021`)
have significant p values (`Pr(>F)` column).
It's a bit surprising that breastfeeding and birth type are not significant (p > 0.05),
though it may be because we're including older kids.
What happens if we only look at the kids under 2 years old?

### Young kids

```julia; results="hidden"
# get kids that are less than 1.5 years old
young = map(a-> !ismissing(a) && a <= 365*1, kidsmeta.correctedAgeDays)
youngkids = view(kids, sites=young)

# make new distance matrix
youngkids_dm = pairwise(BrayCurtis(), youngkids, dims=2,)
youngkidsmeta = kidsmeta[young, :]

# # Test breasfeeding and formula feeding
# p = permanova(youngkids_dm, youngkidsmeta.breastfed, 10000)
# p[!, :feature] .= "species"
# p[!, :variable] .= "young kids breastfed"
# perm = vcat(perm, p)
#
# p = permanova(youngkids_dm, youngkidsmeta.formulafed, 10000)
# p[!, :feature] .= "species"
# p[!, :variable] .= "young kids formulafed"
# perm = vcat(perm, p)
#
p = permanova(youngkids_dm, youngkidsmeta.birthType, filter=.!ismissing.(youngkidsmeta.birthType))
p[!, :feature] .= "species"
p[!, :variable] .= "young kids birthType"
perm = vcat(perm, p)

filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
```

```julia; echo=false
# just look at last 3 rows
@pt perm[end-2:end, :]
```

Breast feeding is now significant (it wasn't before we included `batch010`).
Formula feeding is not significant;
this could just be a numbers game,
or a result of how we're defining it
(kids who get both breastmilk and formula are included).

### Brain Data

One of the things making this cohort unique
is that we have brain volume data collected from fMRI scans
taken within one month of fecal sample collection.

All of the brain volume data is really affected by the age of the kids,
so we need to subtract out that variation.
`BiobakeryUtils` can't handle a PERMANOVA with two variables yet,
so we need to do this directly using `RCall.jl`.

```julia
# normalize brain volume measures
kidsmeta.total_lowres = map(row-> sum(row[[:white_matter_volume, :grey_matter_volume, :csf_volume]]), eachrow(kidsmeta))

kidsmeta.white_matter_normed = kidsmeta.white_matter_volume ./ kidsmeta.total_lowres
kidsmeta.grey_matter_normed = kidsmeta.grey_matter_volume ./ kidsmeta.total_lowres
kidsmeta.csf_normed = kidsmeta.csf_volume ./ kidsmeta.total_lowres
```

```julia; results="hidden"
using RCall

filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:white_matter_normed]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :white_matter_normed]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + white_matter_normed,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
```
```julia; echo=false
@pt p
```

The second row is `white_matter_normed`.

```julia; results="hidden"
p[!, :feature] .= "species"
p[!, :variable] .= "white_matter_normed"
perm = vcat(perm, p[[2],:])
```
```julia; echo=false
@pt perm
```

Let's look at some other brain measures.

```julia; results="hidden"
## grey matter
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:grey_matter_normed]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :grey_matter_normed]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + grey_matter_normed,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "grey_matter_normed"
perm = vcat(perm, p[[2],:])

## CSF (cerebrospinal fluid volume)
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:csf_normed]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :csf_normed]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + csf_normed,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "csf_normed"
perm = vcat(perm, p[[2],:])
```
```julia; echo=false
@pt perm[end-2:end,:]
```

Only CSF and White matter are significant,
but there's some concern that, even including age in the analysis,
some of the age effect is bleeding through.

We can also look at brain regions as identified by the hires scans.
In addition to normalizing by age,
we'll also divide each volume by the total brain volume.

```julia; results="hidden"
## Brain volume
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:hires_total]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :hires_total]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm
R"""
p <- adonis(r_dm ~ correctedAgeDays + hires_total,
            data=r_meta, permutations = 10000)
"""

@rget p

p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "hires_total"
perm = vcat(perm, p[[2],:])
```
```julia; echo=false
@pt perm[end:end,:]
```

```julia
## Cerebellum
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:cerebellar]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :cerebellar, :hires_total]]
r_meta.cerebellar_normed = r_meta.cerebellar ./ r_meta.hires_total


r_meta = r_meta[!, [:correctedAgeDays, :cerebellar_normed]]
r_dm = kids_dm[filt,filt]

CSV.write("/home/kevin/Desktop/df.csv", r_meta)
CSV.write("/home/kevin/Desktop/dm.csv", DataFrame(r_dm), writeheader=false)
@rput r_meta
@rput r_dm

R"""
p <- adonis(terms(as.formula("r_dm ~  correctedAgeDays + cerebellar_normed"), keep.order=TRUE),
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "cerebellar_normed"
perm = vcat(perm, p[[2],:])

## Subcortical
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:subcortical]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :subcortical, :hires_total]]
r_meta.subcortical_normed = r_meta.subcortical ./ r_meta.hires_total
r_meta = r_meta[!, [:correctedAgeDays, :subcortical_normed]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + subcortical_normed,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "subcortical_normed"
perm = vcat(perm, p[[2],:])


## Neocortical
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:neocortical]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :neocortical, :hires_total]]
r_meta.neocortical_normed = r_meta.neocortical ./ r_meta.hires_total
r_meta = r_meta[!, [:correctedAgeDays, :neocortical_normed]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + neocortical_normed,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "neocortical_normed"
perm = vcat(perm, p[[2],:])

## Limbic
filt = map(row-> !ismissing(row[:correctedAgeDays]) && !ismissing(row[:limbic]), eachrow(kidsmeta))
r_meta = kidsmeta[filt, [:correctedAgeDays, :limbic, :hires_total]]
r_meta.limbic = r_meta.limbic ./ r_meta.hires_total
r_meta = r_meta[!, [:correctedAgeDays, :limbic]]
r_dm = kids_dm[filt,filt]
@rput r_meta
@rput r_dm

R"""
p <- adonis(r_dm ~ correctedAgeDays + limbic,
            data=r_meta, permutations = 10000)
"""

@rget p
p = p[:aov_tab]
p[!, :feature] .= "species"
p[!, :variable] .= "limbic"
perm = vcat(perm, p[[2],:])
```
```julia; echo=false
filter!(r-> !ismissing(r[Symbol("Pr(>F)")]), perm)
@pt perm[end-4:end,:]
```

### Cognitive Assessments

Cognitive development is measured using standard tests for certain age groups.
In notebook 2, we converted these test scores
so they are comparable across age groups.

```julia; results="hidden"
p = permanova(kids_dm, kidsmeta.cogScore, filter=.!ismissing.(kidsmeta.cogScore))
p[!, :feature] .= "species"
p[!, :variable] .= "cogScore"
perm = vcat(perm, p[[1],:])
```
```julia; echo=false
@pt perm[end:end, :]
```

Let's save the output after correcting for multiple testing.
We'll use the [Benjamini-Hochberg method](https://en.wikipedia.org/wiki/False_discovery_rate#Benjamini%E2%80%93Hochberg_procedure)
for FDR control.

```julia; results="hidden"
using MultipleTesting

perm.p_value = Float64.(perm[!,Symbol("Pr(>F)")])
perm.q_value = adjust(perm.p_value, BenjaminiHochberg())
sort!(perm, :q_value)

# reorder columns
perm = perm[!,[:feature, :variable, :R2, :p_value, :q_value]]
```
```julia; echo=false
@pt perm
```


```julia; echo=false; results="hidden"
CSV.write(joinpath(tables, "tax_permanovas.csv"), perm)
```

Let's see what that looks like in graphical form using `StatsPlots`.

```julia
sort!(perm, [:R2])

# [1:end-1] removes the ~80% variation explained by subject ID
bar(perm[1:end-1, :R2] .* 100,
    xticks=(1:(size(perm,1)-1), perm[1:end-1, :variable]),
    xrotation=45, color=:grey)

for i in eachindex(perm[!,:R2])
    r2 = perm[i, :R2] * 100
    q = perm[i, :q_value]
    kind = perm[!,:variable]
    if q > 0.05
        continue
    elseif q > 0.01
        stars = "*"
    elseif q > .001
        stars = "**"
    else
        stars = "***"
    end
    annotate!(i, r2+.2, text(stars, :center))
end

plot!(legend=false, title="Taxonomic Profiles PERMANOVA",
    ylabel="% Variance explainable")
```
```julia; echo=false; results="hidden"
savefig(joinpath(figures, "tax_permanovas.svg"))
```
